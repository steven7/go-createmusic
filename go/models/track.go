package models

import (
	"github.com/jinzhu/gorm"
)


// Track is used to represent images stored in a Gallery.
// The sound file is NOT stored in the database, and instead
// references data stored on disk.
type Track struct {
	gorm.Model
	UserID 		    	 uint       `gorm:"not_null;index"  json:"userID"`
	Title  		    	 string     `gorm:"not_null"  json:"title"`
	Artist  	    	 string     `gorm:"-"  json:"artist"`
	lengthInSeconds 	 int        `gorm:"-"  json:"lengthInSeconds"`
	Description     	 string	    `gorm:"not_null"  json:"description"`
	CoverImage      	 File  	    `gorm:"-"  json:"coverImage"`
	MusicFile  	    	 File 	    `gorm:"-"  json:"musicFile"`
	CoverImageFilename   string     `gorm:"-"  json:"coverImageFilename"`
	MusicFileFilename    string 	`gorm:"-"  json:"musicFileFilename"`
	CoverImageURL   	 string     `gorm:"-"  json:"coverImageURL"` /// I think this is correct with client side render
	MusicFileURL    	 string 	`gorm:"-"  json:"musicFileURL"`  /// I think this is correct with client side render
	Filename  	    	 string	    `gorm:"not_null"  json:"filename"`
	Images 		    	 []Image    `gorm:"-"`
}



func NewTrackService(db *gorm.DB) TrackService {
	return &trackService{
		TrackDB: &trackValidator{
			TrackDB: &trackGorm{
				db: db,
			},
		},
	}
}

type TrackService interface {
	TrackDB
}

type trackService struct {
	TrackDB
}

// OAuthDB is used to interact with the galleries database.
//
// For pretty much all single gallery queries:
// If the track is found, we will return a nil error
// If the track is not found, we will return ErrNotFound
// If there is another error, we will return an error with
// more information about what went wrong. This may not be
// an error generated by the models package.
type TrackDB interface {
	ByID(id uint) (*Track, error)
	ByUserID(userID uint) ([]Track, error)
	Create(track *Track) error
	Update(track *Track) error
	Delete(id uint) error
}

type trackValidator struct {
	TrackDB
}


var _ TrackDB = &trackGorm{}

type trackGorm struct {
	db *gorm.DB
}

func (tg *trackGorm) ByID(id uint) (*Track, error) {
	var track Track
	db := tg.db.Where("id = ?", id)
	err := first(db, &track)
	if err != nil {
		return nil, err
	}
	return &track, nil
}

func (tg *trackGorm) ByUserID(userID uint) ([]Track, error) {
	var tracks []Track
	db := tg.db.Where("user_id = ?", userID)
	if err := db.Find(&tracks).Error; err != nil {
		return nil, err
	}
	return tracks, nil
}

func (tg *trackGorm) Create(track *Track) error {
	return tg.db.Create(track).Error
}

func (tg *trackGorm) Update(track *Track) error {
	return tg.db.Save(track).Error
}

func (tg *trackGorm) Delete(id uint) error {
	track := Gallery{Model: gorm.Model{ID: id}}
	return tg.db.Delete(&track).Error
}

//
//
//  Validator functions
//
//

func (tv *trackValidator) Create(track *Track) error {
	err := runTrackValFns(track,
		tv.userIDRequired) // ,
		// tv.titleRequired)
	if err != nil {
		return err
	}
	return tv.TrackDB.Create(track)
}

func (tv *trackValidator) userIDRequired(t *Track) error {
	if t.UserID <= 0 {
		return ErrUserIDRequired
	}
	return nil
}

func (tv *trackValidator) titleRequired(t *Track) error {
	if t.Title == "" {
		return ErrTitleRequired
	}
	return nil
}

func (tv *trackValidator) Update(track *Track) error {
	err := runTrackValFns(track,
		tv.userIDRequired,
		tv.titleRequired)
	if err != nil {
		return err
	}
	return tv.TrackDB.Update(track)
}

func (tv *trackValidator) nonZeroID(track *Track) error {
	if track.ID <= 0 {
		return ErrIDInvalid
	}
	return nil
}

func (tv *trackValidator) Delete(id uint) error {
	var track Track
	track.ID = id
	if err := runTrackValFns(&track, tv.nonZeroID); err != nil {
		return err
	}
	return tv.TrackDB.Delete(track.ID)
}


type trackValFn func(*Track) error

func runTrackValFns(track *Track, fns ...trackValFn) error {
	for _, fn := range fns {
		if err := fn(track); err != nil {
			return err
		}
	}
	return nil
}

func (t *Track) getCoverImage() File {
	return t.CoverImage
}

func (t *Track) ImagesSplitN(n int) [][]Image {
	ret := make([][]Image, n)
	for i := 0; i < n; i++ {
		ret[i] = make([]Image, 0)
	}
	for i, img := range t.Images {
		bucket := i % n
		ret[bucket] = append(ret[bucket], img)
	}
	return ret
}